import { db } from '@/lib/firebase';
import { collection, addDoc, doc, getDoc, updateDoc, Timestamp, query, where, getDocs } from 'firebase/firestore';
import { FormField } from '@/types/form';
import { DatasetSchema, DatasetField, DatasetFieldType, DATASET_COLLECTIONS } from '@/lib/dataset-schema';

/**
 * Generate a dataset schema from form fields
 */
export function generateSchemaFromFormFields(fields: FormField[]): DatasetSchema {
  const schemaFields: DatasetField[] = fields.map(field => {
    let dataType: DatasetFieldType = 'text';
    
    // Map form field types to dataset data types
    switch (field.type) {
      case 'number':
        dataType = 'number';
        break;
      case 'date':
        dataType = 'date';
        break;
      case 'checkbox':
        dataType = 'checkbox';
        break;
      case 'email':
        dataType = 'email';
        break;
      case 'phone':
        dataType = 'phone';
        break;
      case 'textarea':
        dataType = 'textarea';
        break;
      case 'select':
        dataType = 'select';
        break;
      case 'radio':
        dataType = 'radio';
        break;
      case 'text':
      default:
        dataType = 'text';
        break;
    }

    const schemaField: DatasetField = {
      name: field.id,
      label: field.label,
      type: dataType,
      required: field.required || false,
      metadata: {
        description: field.placeholder || `${field.label} field`,
      },
    };

    // Only add validation if it exists
    if (field.validation) {
      schemaField.validation = {
        ...(field.validation.min !== undefined && { min: field.validation.min }),
        ...(field.validation.max !== undefined && { max: field.validation.max }),
        ...(field.validation.pattern !== undefined && { pattern: field.validation.pattern }),
      };
    }

    // Only add placeholder if it exists
    if (field.placeholder) {
      schemaField.metadata!.placeholder = field.placeholder;
    }

    // Only add options if they exist
    if (field.options && field.options.length > 0) {
      schemaField.options = field.options;
    }

    return schemaField;
  });

  return {
    version: '1.0',
    fields: schemaFields,
  };
}

/**
 * Create a new dataset for a form
 */
export async function createDatasetForForm(
  formId: string,
  formTitle: string,
  formFields: FormField[]
): Promise<string> {
  try {
    const schema = generateSchemaFromFormFields(formFields);
    const now = new Date();
    
    const datasetData = {
      name: `${formTitle} - Dataset`,
      description: `Automatically generated dataset for form: ${formTitle}`,
      sourceApplication: 'LeadershipConnections',
      sourceFormId: formId,
      sourceFormTitle: formTitle,
      schema,
      status: 'active',
      metadata: {
        recordCount: 0,
        createdAt: Timestamp.fromDate(now),
        autoGenerated: true,
        linkedFormId: formId,
      },
      createdAt: Timestamp.fromDate(now),
      updatedAt: Timestamp.fromDate(now),
    };

    const docRef = await addDoc(collection(db, DATASET_COLLECTIONS.datasets), datasetData);
    
    console.log(`‚úÖ Created dataset ${docRef.id} for form ${formId}`);
    return docRef.id;
  } catch (error) {
    console.error('Error creating dataset for form:', error);
    throw error;
  }
}

/**
 * Check if a dataset exists for a form
 */
export async function getDatasetForForm(formId: string): Promise<string | null> {
  try {
    const datasetsQuery = query(
      collection(db, DATASET_COLLECTIONS.datasets),
      where('sourceFormId', '==', formId),
      where('status', '==', 'active')
    );
    
    const snapshot = await getDocs(datasetsQuery);
    
    if (snapshot.empty) {
      return null;
    }
    
    return snapshot.docs[0].id;
  } catch (error) {
    console.error('Error checking for existing dataset:', error);
    return null;
  }
}

/**
 * Update dataset schema when form fields change
 */
export async function updateDatasetSchema(
  datasetId: string,
  formFields: FormField[]
): Promise<void> {
  try {
    const schema = generateSchemaFromFormFields(formFields);
    const datasetRef = doc(db, DATASET_COLLECTIONS.datasets, datasetId);
    
    await updateDoc(datasetRef, {
      schema,
      updatedAt: Timestamp.fromDate(new Date()),
      'metadata.schemaVersion': (schema.version || '1.0'),
    });
    
    console.log(`‚úÖ Updated schema for dataset ${datasetId}`);
  } catch (error) {
    console.error('Error updating dataset schema:', error);
    throw error;
  }
}

/**
 * Link a form to a dataset
 */
export async function linkFormToDataset(
  formId: string,
  datasetId: string
): Promise<void> {
  try {
    const formRef = doc(db, 'customForms', formId);
    
    await updateDoc(formRef, {
      datasetEnabled: true,
      datasetId,
      datasetLinkedAt: Timestamp.fromDate(new Date()),
      updatedAt: Timestamp.fromDate(new Date()),
    });
    
    console.log(`‚úÖ Linked form ${formId} to dataset ${datasetId}`);
  } catch (error) {
    console.error('Error linking form to dataset:', error);
    throw error;
  }
}

/**
 * Auto-create and link dataset for form submission
 * This is called when a form is submitted for the first time
 */
export async function ensureDatasetForForm(
  formId: string,
  formTitle: string,
  formFields: FormField[]
): Promise<string> {
  try {
    // Check if dataset already exists
    let datasetId = await getDatasetForForm(formId);
    
    if (datasetId) {
      console.log(`üìä Using existing dataset ${datasetId} for form ${formId}`);
      return datasetId;
    }
    
    // Create new dataset
    console.log(`üÜï Creating new dataset for form ${formId}`);
    datasetId = await createDatasetForForm(formId, formTitle, formFields);
    
    // Link form to dataset
    await linkFormToDataset(formId, datasetId);
    
    return datasetId;
  } catch (error) {
    console.error('Error ensuring dataset for form:', error);
    throw error;
  }
}

/**
 * Delete dataset and all its records
 */
export async function deleteDataset(datasetId: string): Promise<void> {
  try {
    // Mark dataset as deleted
    const datasetRef = doc(db, DATASET_COLLECTIONS.datasets, datasetId);
    await updateDoc(datasetRef, {
      status: 'deleted',
      deletedAt: Timestamp.fromDate(new Date()),
      updatedAt: Timestamp.fromDate(new Date()),
    });
    
    // Mark all records as deleted
    const recordsQuery = query(
      collection(db, DATASET_COLLECTIONS.records),
      where('datasetId', '==', datasetId),
      where('status', '==', 'active')
    );
    
    const snapshot = await getDocs(recordsQuery);
    const deletePromises = snapshot.docs.map(doc => 
      updateDoc(doc.ref, {
        status: 'deleted',
        deletedAt: Timestamp.fromDate(new Date()),
      })
    );
    
    await Promise.all(deletePromises);
    
    console.log(`üóëÔ∏è Deleted dataset ${datasetId} and ${snapshot.size} records`);
  } catch (error) {
    console.error('Error deleting dataset:', error);
    throw error;
  }
}

/**
 * Unlink form from dataset (without deleting the dataset)
 */
export async function unlinkFormFromDataset(formId: string): Promise<void> {
  try {
    const formRef = doc(db, 'customForms', formId);
    
    await updateDoc(formRef, {
      datasetEnabled: false,
      datasetId: null,
      datasetUnlinkedAt: Timestamp.fromDate(new Date()),
      updatedAt: Timestamp.fromDate(new Date()),
    });
    
    console.log(`üîó Unlinked form ${formId} from dataset`);
  } catch (error) {
    console.error('Error unlinking form from dataset:', error);
    throw error;
  }
}

/**
 * Get dataset statistics
 */
export async function getDatasetStats(datasetId: string): Promise<{
  recordCount: number;
  lastRecordAt: Date | null;
  status: string;
} | null> {
  try {
    const datasetRef = doc(db, DATASET_COLLECTIONS.datasets, datasetId);
    const datasetSnap = await getDoc(datasetRef);
    
    if (!datasetSnap.exists()) {
      return null;
    }
    
    const data = datasetSnap.data();
    return {
      recordCount: data.metadata?.recordCount || 0,
      lastRecordAt: data.metadata?.lastRecordAt?.toDate() || null,
      status: data.status || 'unknown',
    };
  } catch (error) {
    console.error('Error getting dataset stats:', error);
    return null;
  }
}
